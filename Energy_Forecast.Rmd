---
title: "Energy Forecast"
output: html_notebook
---

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

Import packages
```{r}
library(haven)
library(ggplot2)
library(lubridate)
library(chron)
library(dplyr)
library(xts)
library(gdata)
library(forecast)
```
Set the working directory and read in data
```{r}
#Read in data
setwd('/Users/gabbynyirjesy/Desktop/GitHub/Forecasting')
energy_data <- read.csv('AEP_hourly.csv')
head(energy_data)
```
Convert "Datetime" column to a timestamp
```{r}
energy_data$timestamp = strptime(energy_data$Datetime, "%Y-%m-%d %H:%M:%S")
head(energy_data)
```
Plot entire time series
```{r}
plot(energy_data$timestamp, energy_data$AEP_MW, xaxt="n", type = 'l')
```

```{r}
min(energy_data$AEP_MW)
```
```{r}
min(energy_data$Datetime)
```

Determine how many data points to save in the test set (want to have a year of data)
```{r}
#Determine length of full year of data
timesteps = length(energy_data[lubridate::year(energy_data$Datetime) == 2006,]$Datetime)
print(timesteps)
```
How many time steps for each day?
```{r}
unique(lubridate::year(energy_data$Datetime))
```

See if there are an equal number of time points for each year
```{r}
for (year in unique(lubridate::year(energy_data$Datetime))){
print(paste0(year,': ',length(energy_data[lubridate::year(energy_data$Datetime) == year,]$Datetime)))
}
```
The data is hourly. Will create a time_index array indicating this
```{r}
time_index <- seq(from = as.POSIXct(min(energy_data$Datetime)),
                  to = as.POSIXct(max(energy_data$Datetime)),
                  by="hour")
```
Check to see if all repeat timesteps of energy data are unique
```{r}
test <- unique(energy_data)
length(test) == length(energy_data)
```

Check to see which timesteps are repeated
```{r}
dupes <- energy_data$Datetime[duplicated(energy_data$Datetime)]
energy_data[energy_data$Datetime %in% dupes,]
```
Assume the duplicates should be aggregated to have one AEP_MW value for each datetime
```{r}
energy_data <- energy_data %>%
  group_by(Datetime) %>%
  summarise(sum(AEP_MW))
```
Rename columns
```{r}
energy_data <- energy_data %>%
  rename(
    AEP_MW = `sum(AEP_MW)`
  )
```
Impute n/a's with zero
```{r}
energy_data$AEP_MW[is.na(energy_data$AEP_MW)] <- 0
```

Split data into train/test sets, cutting data with 1 full year of test data remaining
```{r}
cut_value <- paste0(as.Date(max(energy_data$Datetime)) %m-% months(12),
                    substring(max(energy_data$Datetime), 11,19))
print(cut_value)
energy_data_test_ind <- which(energy_data$Datetime > "2017-08-03 00:00:00")
energy_data_test <- energy_data[energy_data_test_ind,]
energy_data_train <- energy_data[-energy_data_test_ind,]
```

Turn data frame into a time series object
```{r}
start_date <- as.Date(min(energy_data_train$Datetime))
energy_data_train$timestamp <- as.POSIXct(energy_data_train$Datetime,
                                          format="%Y-%m-%d %H:%M:%S",
                                          tz='UTC')
ts_train <- xts(x = energy_data_train$AEP_MW, order.by=energy_data_train$timestamp)
#ts_train <- ts(energy_data_train, start = c(year(start_date),month(start_date), day(start_date)),
#                                            frequency = 365.25)
#msts can handle multiple seasonality (from the forecast package)
#components.ts = decompose(energy_data)
#plot(components.ts)
```

View time series decomposition
```{r}
attr(ts_train, 'frequency') <- 8766
periodicity(ts_train)
plot(decompose(as.ts(ts_train))) 
```

```{r}
best_fourier <- function(ts_train){
  require(forecast)
  models <- lapply(seq(1,6), function(j){
    try(auto.arima(ts_train,
                   xreg = fourier(ts_train, K=j),
                   seasonal = FALSE,
                   stepwise = FALSE,
                   approximation = FALSE,
                   ic = 'aicc'))
  })
  best_forecast <- which.min(sapply(models, function(x){x[['aicc']]}))
  return(list(aicc = models[[best_forecast]]$aicc, model = models[[best_forecast]], k= best_forecast))
}
```
```{r}
best_arima <- function(ts_train){
  require(forecast)
  model <- try(auto.arima(ts_train,
                          stepwise = FALSE,
                          approximation = FALSE,
                          seasonal = FALSE,
                          ic = 'aicc'))
  return(list(aicc = model$aicc, model = model))
  
}
```

Run the fourier model
```{r}
best_fourier_result <- best_fourier(ts_train)
```
```{r}
forecast_data <- try(forecast(best_fourier_result$model, level=c(80,95), xreg = fourier(ts_train, K=best_fourier_result$k, h= 8579)))
plot(forecast_data)
```

```{r}
best_arima_result <- best_arima(ts_train)
```
```{r}
forecast_data <- try(forecast(best_arima_result$model, level=c(80,95), h= 8579))
plot(forecast_data)
```


Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.
When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file). 

