---
title: "Energy Forecast"
output: html_notebook
---

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

Import packages
```{r}
library(haven)
library(ggplot2)
library(lubridate)
library(chron)
library(dplyr)
library(xts)
```
Set the working directory and read in data
```{r}
#Read in data
setwd('/Users/gabbynyirjesy/Desktop/GitHub/Forecasting')
energy_data <- read.csv('AEP_hourly.csv')
head(energy_data)
```
Convert "Datetime" column to a timestamp
```{r}
energy_data$timestamp = strptime(energy_data$Datetime, "%Y-%m-%d %H:%M:%S")
head(energy_data)
```
Plot entire time series
```{r}
plot(energy_data$timestamp, energy_data$AEP_MW, xaxt="n", type = 'l')
```



Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.
```{r}
min(energy_data$AEP_MW)
```
```{r}
min(energy_data$Datetime)
```

Determine how many data points to save in the test set (want to have a year of data)
```{r}
#Determine length of full year of data
timesteps = length(energy_data[lubridate::year(energy_data$Datetime) == 2006,]$Datetime)
print(timesteps)
```
How many time steps for each day?
```{r}
unique(lubridate::year(energy_data$Datetime))
```

See if there are an equal number of time points for each year
```{r}
for (year in unique(lubridate::year(energy_data$Datetime))){
print(paste0(year,': ',length(energy_data[lubridate::year(energy_data$Datetime) == year,]$Datetime)))
}
```
The data is hourly. Will create a time_index array indicating this
```{r}
time_index <- seq(from = as.POSIXct(min(energy_data$Datetime)),
                  to = as.POSIXct(max(energy_data$Datetime)),
                  by="hour")
```
Check to see if all repeat timesteps of energy data are unique
```{r}
test <- unique(energy_data)
length(test) == length(energy_data)
```

Check to see which timesteps are repeated
```{r}
dupes <- energy_data$Datetime[duplicated(energy_data$Datetime)]
energy_data[energy_data$Datetime %in% dupes,]
```
Assume the duplicates should be aggregated to have one AEP_MW value for each datetime
```{r}
energy_data <- energy_data %>%
  group_by(Datetime) %>%
  summarise(sum(AEP_MW))
```
Split data into train/test sets, cutting data with 1 full year of test data remaining
```{r}
cut_value <- paste0(as.Date(max(energy_data$Datetime)) %m-% months(12), substring(test, 11,19))
print(cut_value)
energy_data_test_ind <- which(energy_data$Datetime > "2017-08-03 00:00:00")
energy_data_test <- energy_data[energy_data_test_ind,]
energy_data_train <- energy_data[-energy_data_test_ind,]
```


```{r}
start_date <- as.Date(min(energy_data_train$Datetime))
energy_data_train$timestamp <- strptime(energy_data_train$Datetime, "%Y-%m-%d %H:%M:%S")
ts_train <- xts(x = energy_data_train, order.by=energy_data_train$timestamp)
#ts_train <- ts(energy_data_train, start = c(year(start_date),month(start_date), day(start_date)),
#                                            frequency = 365.25)
#msts can handle multiple seasonality (from the forecast package)
#components.ts = decompose(energy_data)
#plot(components.ts)
```


When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file). 

